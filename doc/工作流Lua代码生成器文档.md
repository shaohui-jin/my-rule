# 工作流Lua代码生成器文档

## 概述

本系统是一个将可视化工作流的数据转换为Lua代码的代码生成器，主要包含两个核心类：
- `WorkflowAnalyzer`: 工作流分析器，负责分析工作流结构和分支逻辑
- `LuaGenerator`: Lua代码生成器，负责生成最终的Lua代码

系统采用**分析-生成**的两阶段架构，支持复杂的条件分支、汇合点处理、迭代器节点和多种逻辑节点类型。

## 核心架构设计

### 1. 整体设计思路

系统采用**分析-生成**的两阶段架构：
1. **分析阶段**: 通过`WorkflowAnalyzer`分析工作流的结构特征、分支逻辑、汇合点和迭代器结构
2. **生成阶段**: 基于分析结果，通过`LuaGenerator`生成对应的Lua代码

这种设计确保了代码生成的准确性和可维护性，支持复杂的嵌套结构、分支逻辑和迭代器处理。

### 2. 核心数据结构

#### 工作流节点类型
- **普通函数节点** (`func`): 执行具体的业务逻辑
- **逻辑节点** (`logic`): 控制流程，包括条件判断、聚合操作、迭代器等
  - `ifelse`: 条件分支节点
  - `aggregate`: 数据聚合节点
  - `global_param`: 全局参数节点
  - `sub_property_extractor`: 子属性提取器节点
  - `global_variable`: 全局变量节点
  - `type_converter`: 类型转换器节点
  - `custom_function`: 自定义函数节点
  - `iterator`: 迭代器节点
  - `decision_tables_function`: 决策表函数节点
  - `external_data_table`: 外部数据表节点

#### 节点分析信息
```typescript
interface NodeAnalysis {
  type: 'normal' | 'condition' | 'iterator'  // 节点类型
  level: number                 // 节点层级（用于嵌套结构）
  branchInfo?: BranchInfo       // 所属分支信息
  isMergePoint?: boolean        // 是否是汇合点
  isSameSourceMergePoint?: boolean    // 是否是同源分支汇合点
  isDifferentSourceMergePoint?: boolean // 是否是不同源分支汇合点
  localBranches?: string[]      // 每条入边最近的ifelse分支ID
  rootBranches?: string[]       // 每条入边最上游的ifelse分支ID
  branchSourceMap?: Record<string, string> // 分支ID -> 实际上游节点ID
}
```

#### 分支信息
```typescript
interface BranchInfo {
  logicNodeId: string           // 所属的逻辑节点ID
  branchType: 'if' | 'elseif' | 'else' // 分支类型
  branchIndex: number           // 分支序号
  condition: string             // 条件表达式
  nodes: string[]               // 该分支下的所有节点ID
  exitNodes: string[]           // 该分支的出口节点ID
}
```

#### 执行顺序结果
```typescript
interface ExecutionOrderResult {
  main: string[]                // 主执行路径
  [iteratorId: string]: string[] // 迭代器ID -> 执行路径的映射
}
```

## WorkflowAnalyzer 核心实现逻辑

### 1. 分析流程

分析器按照以下步骤进行工作流分析：

1. **初始化节点映射**: 建立节点和边的索引Map，提高查询效率
2. **生成执行顺序**: 使用拓扑排序确定节点的执行顺序，支持迭代器分支
3. **节点类型识别**: 识别每个节点的类型（普通/条件/迭代器）
4. **层级计算**: 计算每个节点在嵌套结构中的层级
5. **分支分析**: 分析条件节点的分支结构，支持端口感知
6. **汇合点处理**: 识别和处理分支汇合点，区分同源和不同源汇合
7. **出口节点查找**: 确定每个分支的出口节点
8. **全局变量路径处理**: 处理全局参数节点的执行路径修改
9. **迭代器内部全局变量处理**: 处理迭代器内部的全局参数路径
10. **不同源汇合点特殊处理**: 处理跨分支的数据流合并

### 2. 关键算法

#### 拓扑排序算法
- 使用入度统计和队列实现
- 确保节点按照依赖关系正确排序
- 检测循环依赖并给出警告
- 支持复杂的多入边和多出边结构
- 支持迭代器节点的特殊处理

#### 层级计算算法
```typescript
层级 = max(所有父节点层级) + (父节点是条件节点 ? 1 : 0)
```

#### 分支汇合点识别
- 识别有多个入边的节点
- 按逻辑节点分组处理汇合
- 标记汇合点和来源分支
- 区分同源分支汇合点和不同源分支汇合点

#### 端口感知的分支查找
- 支持基于端口的分支识别
- 递归查找最近和根ifelse分支
- 处理复杂的嵌套分支结构
- 区分同源分支汇合点和不同源分支汇合点

#### 迭代器节点分析
- 识别迭代器节点和其子节点
- 分析迭代器内部的执行路径
- 处理迭代器内部的全局变量路径
- 支持嵌套迭代器结构

### 3. 特殊设计规则

#### 分支结构规则
- 条件节点自动创建分支信息
- 分支按端口顺序排序（if -> elseif -> else）
- 每个分支维护独立的节点列表和出口节点
- 支持端口感知的分支路径收集

#### 汇合点处理规则
- 只有来自同一逻辑节点的多个分支才能形成汇合
- 汇合点的层级与对应的条件节点层级相同
- 汇合点会更新相关分支的出口节点信息
- 不同源汇合点需要特殊的分支标志处理

#### 不同源汇合点处理
- 识别来自不同根ifelse节点的汇合点
- 为每个分支创建执行标志变量
- 生成分组条件表达式
- 支持跨分支的数据流合并

#### 迭代器节点处理规则
- 迭代器节点包含子节点列表
- 支持迭代器内部的全局变量处理
- 迭代器内部节点有独立的执行路径
- 支持嵌套迭代器结构

## LuaGenerator 核心实现逻辑

### 1. 代码生成流程

生成器按照以下顺序生成Lua代码：

1. **模块收集**: 收集所有需要的Lua模块
2. **模块声明**: 生成require语句，支持动态路径
3. **函数声明**: 生成主函数框架
4. **变量声明**: 声明所有节点结果变量和分支标志
5. **主流程生成**: 按执行顺序生成业务逻辑
6. **迭代器代码块生成**: 生成迭代器相关的代码
7. **不同源汇合点处理**: 生成特殊的分支标志逻辑
8. **返回语句**: 生成函数返回值
9. **模块导出**: 生成模块导出语句

### 2. 核心生成策略

#### 变量命名规则
- 普通节点: `result_{nodeId}`
- 条件节点: `tempResult_{nodeId}`
- 分支标志: `flag_{branchId}`
- 汇合标志: `merge_{rootIds}_{index}`
- 避免变量名冲突和重复声明

#### 条件表达式转换
- 将JavaScript语法转换为Lua语法
- 替换逻辑运算符: `&&` → `and`, `||` → `or`
- 替换比较运算符: `===` → `==`, `!==` → `~=`
- 处理数组长度: `.length` → `#`
- 支持复杂的嵌套条件表达式

#### 函数参数生成
- 支持输入参数和节点连接两种来源
- 处理条件节点的真实来源查找
- 支持汇合点的特殊变量名处理
- 递归追溯参数链路直到非条件节点

#### 迭代器代码生成
- 生成迭代器外层循环结构
- 处理迭代器内部节点的代码生成
- 支持迭代器内部的全局变量处理
- 生成迭代结果的汇总逻辑

### 3. 特殊处理逻辑

#### 条件分支生成
```lua
if 条件表达式 then
    -- 分支内节点代码
    tempResult_逻辑节点ID = result_出口节点ID
    flag_分支ID = true
elseif 条件表达式 then
    -- 分支内节点代码
    tempResult_逻辑节点ID = result_出口节点ID
    flag_分支ID = true
else
    -- 分支内节点代码
    tempResult_逻辑节点ID = result_出口节点ID
    flag_分支ID = true
end
```

#### 不同源汇合点处理
```lua
-- 不同源分支汇合点
if (flag_分支1 or flag_分支2) and (flag_分支3 or flag_分支4) then
    -- 汇合点及其子孙节点代码
    merge_根节点1_根节点2_1 = result_最后节点ID
end
```

#### 迭代器代码块生成
```lua
-- 迭代器：节点标题
result_迭代器ID = {}
if 迭代对象 and type(迭代对象) == "table" then
    for i, item in ipairs(迭代对象) do
        local result_起始节点ID = item 
        -- 迭代器内部节点代码
        table.insert(result_迭代器ID, result_最后节点ID)
    end
end
```

#### 聚合节点处理
- 支持多种数据类型的聚合
- 数组类型：使用table.insert合并
- 对象数组：基于ID字段去重
- 简单类型：直接合并到数组
- 类型兼容性检查和过滤

#### 全局参数节点处理
- 支持root、target、context三种全局参数
- 直接赋值到结果变量
- 简化参数传递逻辑

#### 模块导入优化
- 按路径分组模块
- 避免重复导入
- 生成标准的Lua require语句
- 支持动态路径配置

## 扩展组件

### 1. Aggregate 聚合处理器

#### 功能特性
- 支持多种数据类型的聚合
- 类型兼容性检查和过滤
- 字段路径解析和验证
- 智能去重策略

#### 聚合策略
- **简单类型**: 直接合并到数组
- **数组类型**: 合并所有数组元素
- **对象数组**: 基于指定字段去重
- **复杂对象**: 支持嵌套结构合并

#### 字段路径处理
- 支持点分隔的字段路径
- 自动生成Lua字段访问代码
- 字段存在性检查
- 路径格式验证

### 2. GlobalParam 全局参数处理器

#### 功能特性
- 支持root、target、context全局参数
- 支持target[]数组参数
- 直接赋值到结果变量
- 简化参数传递逻辑
- 统一的参数访问接口

### 3. SubPropertyExtractor 子属性提取器

#### 功能特性
- 支持基于路径的属性提取
- 支持遍历和非遍历两种模式
- 支持条件过滤
- 支持数组和对象类型处理

#### 路径格式支持
- 支持点分隔的字段路径
- 支持数组索引访问 `[N].field`
- 支持嵌套路径 `field1.field2.field3`

#### 遍历模式
- **非遍历模式**: 直接提取指定路径的属性
- **遍历模式**: 遍历数组中的每个元素，提取指定属性

### 4. GlobalVariable 全局变量处理器

#### 功能特性
- 支持全局变量的设置和获取
- 支持多种数据类型
- 统一的变量管理接口

### 5. TypeConverter 类型转换器

#### 功能特性
- 支持多种类型转换
- 类型安全检查
- 默认值处理

#### 支持的转换类型
- `toString`: 转换为字符串
- `toNumber`: 转换为数字
- `toBoolean`: 转换为布尔值
- 默认转换为table类型

### 6. DecisionTable 决策表处理器

#### 功能特性
- 支持决策表数据生成
- 支持测试模式日志记录
- 支持复杂的条件判断逻辑

#### 决策表结构
- 支持多行条件配置
- 支持多种输出类型
- 支持条件优先级设置

### 7. ExternalDataTable 外部数据表处理器

#### 功能特性
- 支持外部数据表的引用
- 支持动态数据源配置
- 支持数据表字段映射

## 迭代器管理

### 1. IteratorManager 迭代器管理器

#### 功能特性
- 支持迭代器节点的创建、复制、删除
- 自动管理迭代器子节点的位置和关系
- 支持迭代器折叠/展开状态
- 内置起始节点管理
- 子节点位置同步

#### 迭代器节点特点
- 固定尺寸：450x300px
- 可调整大小
- 支持子节点嵌入
- 内置起始节点（iterator_start）
- 支持折叠/展开功能

#### 迭代器数据结构
```typescript
interface IteratorNode {
  id: string
  funcType: 'logic'
  logicData: { logicType: LogicType.ITERATOR }
  children: string[]           // 子节点ID列表
  inputData: InputData[]       // 输入参数配置
  outputData: OutputData[]     // 输出参数配置
}
```

### 2. 迭代器代码生成策略

#### 外层循环结构
- 生成for循环遍历迭代对象
- 支持ipairs和pairs两种遍历方式
- 自动处理数组和对象类型

#### 内部节点处理
- 递归生成子节点代码
- 支持条件分支和逻辑节点
- 处理迭代器内部的全局变量

#### 结果汇总
- 自动收集每次迭代的结果
- 支持数组和对象类型的结果合并
- 生成最终的迭代器输出

## 关键设计原则

### 1. 数据流一致性
- 确保生成的Lua代码与原始工作流的数据流完全一致
- 正确处理节点间的依赖关系
- 维护变量作用域和生命周期
- 支持复杂的跨分支数据流
- 支持迭代器内部的数据流

### 2. 错误处理
- 对异常情况提供合理的默认值
- 记录详细的错误信息便于调试
- 保证生成过程的健壮性
- 类型兼容性检查和警告

### 3. 代码质量
- 生成清晰可读的Lua代码
- 添加适当的注释说明
- 遵循Lua编程规范
- 优化变量命名和结构

### 4. 扩展性
- 支持新的节点类型扩展
- 模块化的处理器设计
- 可配置的代码生成策略
- 插件化的架构设计

## 使用注意事项

### 1. 工作流设计约束
- 避免循环依赖
- 确保条件分支有明确的出口
- 合理设计数据聚合逻辑
- 注意不同源汇合点的复杂性
- 合理设计迭代器结构

### 2. 性能考虑
- 大型工作流可能需要优化分析算法
- 考虑缓存分析结果
- 监控内存使用情况
- 优化模块导入策略
- 迭代器节点数量控制

### 3. 调试建议
- 启用详细的分析日志
- 检查生成的Lua代码语法
- 验证数据流正确性
- 使用Lua调试工具验证执行结果
- 检查迭代器内部逻辑

## 扩展指南

### 1. 添加新节点类型
1. 在`WorkflowAnalyzer`中添加节点类型识别逻辑
2. 在`LuaGenerator`中添加对应的代码生成逻辑
3. 更新相关的类型定义和接口
4. 添加相应的处理器类

### 2. 自定义处理器
1. 实现处理器接口
2. 在`LuaGenerator`中注册处理器
3. 添加相应的类型检查和错误处理
4. 更新文档和测试用例

### 3. 优化策略
1. 分析性能瓶颈
2. 优化算法复杂度
3. 添加缓存机制
4. 改进内存使用

## 技术特性

### 1. 类型安全
- TypeScript类型检查
- 运行时类型验证
- 类型兼容性检查
- 类型推导优化

### 2. 性能优化
- 索引Map提高查询效率
- 缓存机制减少重复计算
- 内存使用优化
- 算法复杂度控制

### 3. 可维护性
- 模块化架构设计
- 清晰的代码结构
- 完善的错误处理
- 详细的代码注释

## 更新日志

### v3.0.0 (当前版本)
- 新增迭代器节点支持
  - 支持循环处理数据集合
  - 支持嵌套迭代器结构
  - 支持迭代器内部全局变量处理
- 新增子属性提取器节点
  - 支持基于路径的属性提取
  - 支持遍历和非遍历模式
  - 支持条件过滤
- 新增类型转换器节点
  - 支持多种类型转换
  - 类型安全检查
- 新增全局变量节点
  - 支持全局变量管理
  - 统一的变量接口
- 新增决策表函数节点
  - 支持复杂的条件判断
  - 支持测试模式日志
- 新增外部数据表节点
  - 支持外部数据源引用
  - 支持动态数据配置
- 改进分支分析和端口感知
- 增强类型兼容性检查
- 优化代码生成策略
- 完善错误处理和调试功能
- 提升性能和可维护性

### v2.0.0
- 新增不同源汇合点处理功能
- 改进分支分析和端口感知
- 增强类型兼容性检查
- 优化代码生成策略
- 完善错误处理和调试功能
- 提升性能和可维护性

### v1.0.0
- 基础工作流分析功能
- 基础Lua代码生成
- 支持条件分支和聚合节点
- 支持全局参数节点